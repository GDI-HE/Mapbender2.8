<?php
# http://www.mapbender.org/index.php/class_iso19139.php
# Copyright (C) 2002 CCGIS 
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
require_once(dirname(__FILE__)."/../../core/globalSettings.php");
require_once(dirname(__FILE__)."/class_connector.php");
require_once dirname(__FILE__) . "/../../tools/wms_extent/extent_service.conf";
class Iso19139 {
	//values for handling apriori ows metadataurls
	var $fileIdentifier;
	var $createDate;
	var $changeDate;
	var $title;
	var $abstract;
	var $metadata;
	var $datasetId;
	var $datasetIdCodeSpace;
	var $keywords = array();
	var $keywordsThesaurusName = array();
	var $isoCategoryKeys = array();

	var $isoCategories = array();
	var $inspireCategories = array();
	var $customCategories = array();

	var $hierachyLevel;
	var $tmpExtentBegin;
	var $tmpExtentEnd;
	var $refSystem;
	var $randomId;
	var $href;
	var $format;
	var $type;
	var $origin;
	var $owner;
	var $harvestResult;
	var $harvestException;
	//new
	var $lineage;
	var $inspireTopConsistence; //db bool, 't' or 'f'
	var $spatialResType;
	var $spatialResValue;
	var $export2Csw; //db bool, 't' or 'f'
	var $updateFrequency;
	var $dataFormat;
	var $inspireCharset;

	var $linkAlreadyInDB; //bool
	var $fileIdentifierAlreadyInDB; //bool

	function __construct() {
		//initialize empty iso19139 object
		$this->fileIdentifier = "";
		$title->title = "empty iso19139 object title";
		$title->abstract = "empty iso19139 object abstract";
		$this->createDate = "1900-01-01";
		$this->changeDate = "1900-01-01";
		$this->metadata = "";
		$this->datasetId = "";
		$this->datasetIdCodeSpace = "";	
		$this->keywords = array();
		$this->keywordsThesaurusName = array();
		$this->isoCategoryKeys = array();
		//following information is specific to mapbender information model - they are identified by id!
		$this->isoCategories = array();
		$this->inspireCategories = array();
		$this->customCategories = array();
		//
		$this->hierachyLevel = "dataset";
		$this->tmpExtentBegin = "1900-01-01";
		$this->tmpExtentEnd = "1900-01-01";
		$this->randomId = "";
		$this->owner = 0; //dummy entry for metadata owner - in case of metadataURL entries the owner of the corresponding service
		$this->href = "";
		$this->format = "";
		$this->type = "";
		$this->origin = "";
		$this->refSystem = "";
		$this->harvestResult = 0;
		$this->harvestException = "";
		$this->lineage = "";
		$this->inspireTopConsistence = "f";
		$this->spatialResType = "";
		$this->spatialResValue = "";
		$this->export2Csw = "t";
		$this->updateFrequency = "";
		$this->dataFormat = "";
		$this->inspireCharset = "";

		$this->linkAlreadyInDB = false;
		$this->fileIdentifierAlreadyInDB = false;
	}

	public function removeGetRecordTag ($xml) {
		$regex = "#<csw:GetRecordByIdResponse .*?>#";
		$xml = preg_replace($regex,"",$xml);
		$regex = "#</csw:GetRecordByIdResponse>#";
		$xml = preg_replace($regex,"",$xml);
		return $xml;
	}
	
	public function createMapbenderMetadataFromXML($xml){
		$this->metadata = $xml;
		$this->metadata = $this->removeGetRecordTag($this->metadata);
		//$e = new mb_exception($this->metadata);
		libxml_use_internal_errors(true);
		try {
			$iso19139Xml = simplexml_load_string($this->metadata);
			if ($iso19139Xml === false) {
				foreach(libxml_get_errors() as $error) {
        				$err = new mb_exception("class_Iso19139:".$error->message);
    				}
				throw new Exception("class_Iso19139:".'Cannot parse Metadata XML!');
				return false;
			}
		}
		catch (Exception $e) {
    			$err = new mb_exception("class_Iso19139:".$e->getMessage());
			return false;
		}
		//if parsing was successful
		if ($iso19139Xml !== false) {
			//built hashes for category mapping
			$topicCatHash = array();
			$sql = "SELECT md_topic_category_id, md_topic_category_code_en FROM md_topic_category";
			$res = db_query($sql);
			while ($row = db_fetch_array($res)){
				$topicCatHash[$row['md_topic_category_code_en']] = (integer)$row['md_topic_category_id'];
				//$e = new mb_exception("topicCatHash: ".$row['md_topic_category_code_en'] ." : ". $topicCatHash[$row['md_topic_category_code_en']] );	
			}
			//inspire
			$inspireCatHash = array();
			$sql = "SELECT inspire_category_id, inspire_category_code_en FROM inspire_category";
			$res = db_query($sql);
			while ($row = db_fetch_array($res)){
				$inspireCatHash[$row['inspire_category_code_en']] = (integer)$row['inspire_category_id'];
				//$e = new mb_exception("inspireCatHash: ".$row['inspire_category_code_en'] ." : ". $row['inspire_category_id'] );	
			}
			//custom
			//keywords - as text i custom category - special keywords of geoportal instance defined as keys!
			$customCatHash = array();
			$sql = "SELECT custom_category_id, custom_category_key FROM custom_category";
			$res = db_query($sql);
			while ($row = db_fetch_array($res)){
				$customCatHash[$row['custom_category_key']] = (integer)$row['custom_category_id'];
				//$e = new mb_exception("customCatHash: ".$row['custom_category_key'] ." : ". $row['custom_category_id'] );	
			}
			//add namespaces to xml if not given - how? - it is to late now - maybe they were given in the csw tag!
			$e = new mb_exception("Parsing of xml metadata file was successfull"); 
			$this->fileIdentifier = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:fileIdentifier/gco:CharacterString');
			$this->fileIdentifier = $this->fileIdentifier[0];
			$this->createDate = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:dateStamp/gco:Date');
			$this->createDate = $this->createDate[0];
			$this->changeDate = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:dateStamp/gco:Date');
			$this->changeDate = $this->changeDate[0];
			//TODO: check if this is set, maybe DateTime must be searched instead?
			$this->title = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:identificationInfo/gmd:MD_DataIdentification/gmd:citation/gmd:CI_Citation/gmd:title/gco:CharacterString');
			$this->title = $this->title[0];
			//dataset identifier - howto model into md_metadata?
			//check where datasetid is defined - maybe as RS_Identifier or as MD_Identifier see http://inspire.jrc.ec.europa.eu/documents/Metadata/INSPIRE_MD_IR_and_ISO_v1_2_20100616.pdf page 18
			//First check if MD_Identifier is set, then check if RS_Identifier is used!
			//Initialize datasetid
			$this->datasetId = 'undefined';
			$code = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:identificationInfo/gmd:MD_DataIdentification/gmd:citation/gmd:CI_Citation/gmd:identifier/gmd:MD_Identifier/gmd:code/gco:CharacterString');
			if (isset($code[0]) && $code[0] != '') {
				$this->datasetId = $code[0];
				$this->datasetIdCodeSpace = "";	
			} else { //try to read code from RS_Identifier 		
				$code = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:identificationInfo/gmd:MD_DataIdentification/gmd:citation/gmd:CI_Citation/gmd:identifier/gmd:RS_Identifier/gmd:code/gco:CharacterString');
				$codeSpace = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:identificationInfo/gmd:MD_DataIdentification/gmd:citation/gmd:CI_Citation/gmd:identifier/gmd:RS_Identifier/gmd:codeSpace/gco:CharacterString');
				if (isset($codeSpace[0]) && isset($code[0]) && $codeSpace[0] != '' && $code[0] != '') {
					$this->datasetId = $code[0];
					$this->datasetIdCodeSpace = $codeSpace[0];
				} else {
					//neither MD_Identifier nor RS_Identifier are defined in a right way
					$e = new mb_notice("class_iso19139.php: No datasetId found in metadata record!");
				}
			}
			//abstract
			$this->abstract = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:identificationInfo/gmd:MD_DataIdentification/gmd:abstract/gco:CharacterString');
			$this->abstract = $this->abstract[0];
			$this->keywords = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:identificationInfo/gmd:MD_DataIdentification/gmd:descriptiveKeywords/gmd:MD_Keywords/gmd:keyword/gco:CharacterString');
			//get thesaurus name only for found keywords!
			$iKeyword = 0;
			foreach ($this->keywords as $keyword) {
				$thesaurusName = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:identificationInfo/gmd:MD_DataIdentification/gmd:descriptiveKeywords[gmd:MD_Keywords/gmd:keyword/gco:CharacterString="'.$keyword.'"]/gmd:MD_Keywords/gmd:thesaurusName/gmd:CI_Citation/gmd:title/gco:CharacterString');
				$this->keywordsThesaurusName[$iKeyword] = $thesaurusName[0];
				//check if keyword is inspire thematic key and add it into mapbenders inspire category
				if (is_int($inspireCatHash[trim($keyword)])) {
					$this->inspireCategories[] = $inspireCatHash[trim($keyword)];
				}
				//check if keyword is a key in mapbenders custom keywords and add it to mapbenders custom categories
				if (is_int($customCatHash[trim($keyword)])) {
					$this->customCategories[] = $customCatHash[trim($keyword)];
				}
				unset($thesaurusName);
				$iKeyword++;
			}
			$iKeyword = 0;
			$this->isoCategoryKeys = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:identificationInfo/gmd:MD_DataIdentification/gmd:topicCategory/gmd:MD_TopicCategoryCode');
			//create mapbenders internal category objects
			//first for topic categories
			foreach ($this->isoCategoryKeys as $isoKey) {
				$e = new mb_exception("class_iso19139.php: look for iso key: ".$isoKey);
				//test if key is found in hash
				$e = new mb_exception("class_iso19139.php: found: ".$topicCatHash[trim($isoKey)]);
				if (is_int($topicCatHash[trim($isoKey)])) {
					$e = new mb_exception("class_iso19139.php: isoCategories entry added: ".$topicCatHash[trim($isoKey)]);
					$this->isoCategories[] = $topicCatHash[trim($isoKey)];
				}
			}
			//debug output:
			foreach ($this->isoCategories as $category) {
				$e = new mb_exception("class_iso19139.php: isocat: ".$category);
			}
			foreach ($this->inspireCategories as $category) {
				$e = new mb_exception("class_iso19139.php: inspirecat: ".$category);
			}
			foreach ($this->customCategories as $category) {
				$e = new mb_exception("class_iso19139.php: customcat: ".$category);
			}
			$this->hierachyLevel = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:hierarchyLevel/gmd:MD_ScopeCode');
			$this->hierachyLevel = $this->hierachyLevel[0];
			$this->tmpExtentBegin = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:identificationInfo/gmd:MD_DataIdentification/gmd:extent/gmd:EX_Extent/gmd:temporalElement/gmd:EX_TemporalExtent/gmd:extent/gml:TimePeriod/gml:beginPosition');
			$this->tmpExtentBegin = $this->tmpExtentBegin[0];
			$this->tmpExtentEnd = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:identificationInfo/gmd:MD_DataIdentification/gmd:extent/gmd:EX_Extent/gmd:temporalElement/gmd:EX_TemporalExtent/gmd:extent/gml:TimePeriod/gml:endPosition');		
			$this->tmpExtentEnd = $this->tmpExtentEnd[0];
			//spatial_res_type
			//spatial_res_value
			//ref_system
			$this->refSystem = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:referenceSystemInfo/gmd:MD_ReferenceSystem/gmd:referenceSystemIdentifier/gmd:RS_Identifier/gmd:code/gco:CharacterString');
			$this->refSystem = $this->refSystem[0];
			//parse codes to get EPSG:XXXXX TODO use other function to support other codes
			//get last part of string separated by the colon symbol
			$this->refSystem = explode(':',$this->refSystem);
			$this->refSystem = "EPSG:".$this->refSystem[count($this->refSystem)-1];
			//debug output of keywords:
			/*$iKeyword = 0;
			foreach($this->keywords as $keyword) {  
				$e = new mb_exception("Keyword: ".$keyword." - Thesaurus: ".$this->keywordsThesaurusName[$iKeyword]);
				$iKeyword++;
			}
			$iKeyword = 0;*/
			//format
			//lineage
			$this->lineage = $iso19139Xml->xpath('/gmd:MD_Metadata/gmd:dataQualityInfo/gmd:DQ_DataQuality/gmd:lineage/gmd:LI_Lineage/gmd:statement/gco:CharacterString');
			$this->lineage = $this->lineage[0];
			//inspire_charset
			//inspire_top_consistence
			//responsible_party
			//fees
			//"constraints"	
			//fill database with elements:
			return $this;
		} else {
			return false;
		}
	}
	
	public function createFromUrl($url){
		$this->href = $url;
		if ($this->isLinkAlreadyInDB() == false) {
			$this->linkAlreadyInDB = false;
		} else {
			$this->linkAlreadyInDB = true;
		}
		$metadataConnector = new connector($url);
		$metadataConnector->set("timeOut", "5");
		$xml = $metadataConnector->file;
		$mbMetadata = $this->createMapbenderMetadataFromXML($xml);
		return $mbMetadata;
	}

	public function readFromUrl($url){
		$this->href = $url;
		$metadataConnector = new connector($url);
		$metadataConnector->set("timeOut", "10");
		$xml = $metadataConnector->file;
		$this->metadata = $xml;
	}

	public function transformToHtml($layout,$languageCode){
		//TODO!
		$this->metadata = $this->removeGetRecordTag($this->metadata);
		libxml_use_internal_errors(true);
		//TODO don't parse it again, but change the internal parser function!
		try {
			$iso19139Xml = simplexml_load_string($this->metadata);
			if ($iso19139Xml === false) {
				foreach(libxml_get_errors() as $error) {
        				$err = new mb_exception("class_Iso19139:".$error->message);
    				}
				throw new Exception("class_Iso19139:".'Cannot parse Metadata XML!');
				return "error";
			}
		}
		catch (Exception $e) {
    			$err = new mb_exception("class_Iso19139:".$e->getMessage());
			return "error";
		}
		//if parsing was successful
		if ($iso19139Xml !== false) {
			$e = new mb_exception("Parsing of xml metadata file was successfull");
			//register namespaces for parsing content
			$iso19139Xml->registerXPathNamespace("csw", "http://www.opengis.net/cat/csw/2.0.2");
			$iso19139Xml->registerXPathNamespace("gml", "http://www.opengis.net/gml");
			$iso19139Xml->registerXPathNamespace("gco", "http://www.isotc211.org/2005/gco");
			$iso19139Xml->registerXPathNamespace("gmd", "http://www.isotc211.org/2005/gmd");
			$iso19139Xml->registerXPathNamespace("gts", "http://www.isotc211.org/2005/gts");
			$iso19139Xml->registerXPathNamespace("srv", "http://www.isotc211.org/2005/srv");
			$iso19139Xml->registerXPathNamespace("xlink", "http://www.w3.org/1999/xlink");
			include(dirname(__FILE__)."/../../conf/isoMetadata.conf");
			for($a = 0; $a < count($iso19139Hash); $a++) {
				//TODO delete csw:... from following - only parse the metadata record itself
				//$resultOfXpath = $iso19139Xml->xpath('/csw:GetRecordByIdResponse'.$iso19139Hash[$a]['iso19139']);
				$resultOfXpath = $iso19139Xml->xpath($iso19139Hash[$a]['iso19139']);
				for ($i = 0; $i < count($resultOfXpath); $i++) {
					$iso19139Hash[$a]['value'] = $iso19139Hash[$a]['value'].",".$resultOfXpath[$i];
				}
				$iso19139Hash[$a]['value'] = ltrim($iso19139Hash[$a]['value'],',');
			}
			//generate html
			$html = '<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="'.$languageCode.'">';
			$html .= '<body>';
			$metadataStr .= '<head>' . 
				'<title>'._mb("Metadata").'</title>' . 
				'<meta name="description" content="'._mb("Metadata").'" xml:lang="'.$languageCode.'" />'.
				'<meta name="keywords" content="'._mb("Metadata").'" xml:lang="'.$languageCode.'" />'	.	
				'<meta http-equiv="cache-control" content="no-cache">'.
				'<meta http-equiv="pragma" content="no-cache">'.
				'<meta http-equiv="expires" content="0">'.
				'<meta http-equiv="content-language" content="'.$languageCode.'" />'.
				'<meta http-equiv="content-style-type" content="text/css" />'.
				'<meta http-equiv="Content-Type" content="text/html; charset='.CHARSET.'">' . 	
				'</head>';
			$html .= $metadataStr;
			//define the javascripts to include
			$html .= '<link type="text/css" href="../css/metadata.css" rel="Stylesheet" />';
			if ($layout == 'tabs') {
				$html .= '<link type="text/css" href="../extensions/jquery-ui-1.8.1.custom/css/custom-theme/jquery-ui-1.8.5.custom.css" rel="Stylesheet" />';	
				$html .= '<script type="text/javascript" src="../extensions/jquery-ui-1.8.1.custom/js/jquery-1.4.2.min.js"></script>';
				$html .= '<script type="text/javascript" src="../extensions/jquery-ui-1.8.1.custom/js/jquery-ui-1.8.1.custom.min.js"></script>';
				//initialize tabs
				$html .= '<script type="text/javascript">';
				$html .= '$(function() {';
				$html .= '	$("#tabs").tabs();';
				$html .= '});';
				$html .= '</script>';
				//independently define the headers of the parts
				$html .= '<div class="demo">';
				$html .= '<div id="tabs">';
				$html .= '<ul>';
				$html .= 	'<li><a href="#tabs-1">'._mb("Overview").'</a></li>';
				$html .= 	'<li><a href="#tabs-2">'._mb("Properties").'</a></li>';
				$html .= 	'<li><a href="#tabs-3">'._mb("Contact").'</a></li>';
				$html .= 	'<li><a href="#tabs-4">'._mb("Terms of use").'</a></li>';
				$html .= 	'<li><a href="#tabs-5">'._mb("Quality").'</a></li>';
				$html .= 	'<li><a href="#tabs-6">'._mb("Interfaces").'</a></li>';
				$html .= '</ul>';
			}
			if ($layout == 'accordion') {
				$html .= '<link type="text/css" href="../extensions/jquery-ui-1.8.1.custom/css/custom-theme/jquery-ui-1.8.4.custom.css" rel="Stylesheet" />';	
				$html .= '<script type="text/javascript" src="../extensions/jquery-ui-1.8.1.custom/js/jquery-1.4.2.min.js"></script>';
				$html .= '<script type="text/javascript" src="../extensions/jquery-ui-1.8.1.custom/js/jquery-ui-1.8.1.custom.min.js"></script>';
				//define the javascript functions
				$html .= '<script type="text/javascript">';
				$html .= '	$(function() {';
				$html .= '		$("#accordion").accordion();';
				//$html .= '		$("#accordion").accordion({ autoHeight: false});';
				//$html .= '		$("#accordion").accordion({ autoHeight: false , clearStyle: true });';
				$html .= '	});';
				$html .= '	</script>';
				$html .= '<div class="demo">';
				$html .= '<div id="accordion">';
			}
			if ($layout == 'plain') {
				$html .= '<div class="demo">';
				$html .= '<div id="plain">';
			}
			//some placeholders
			$tableBegin =  "<table>\n";
			$t_a = "\t<tr>\n\t\t<th>\n\t\t\t";
			$t_b = "\n\t\t</th>\n\t\t<td>\n\t\t\t";
			$t_c = "\n\t\t</td>\n\t</tr>\n";
			$tableEnd = "</table>\n";
			//**************************overview part begin******************************
			//generate div tags for the content - the divs are defined in the array
			if ($layout == 'accordion') {
				$html .= '<h3><a href="#">'._mb("Overview").'</a></h3>';
				$html .= '<div style="height:300px">';
			}
			if ($layout == 'tabs') {
				$html .= '<div id="tabs-1">';
			}
			if ($layout == 'plain') {
				$html .= '<h3>'._mb("overview").'</h3>';
				$html .= '<div>';
			}
			$html .= '<p>';
			$html .= '<fieldset><legend>'._mb("Metadata").'</legend>';
			$html .= $tableBegin;
			$html .= $t_a."<b>".$iso19139Hash[0]['html']."</b>: ".$t_b.$iso19139Hash[0]['value'].$t_c;
			$html .= $t_a."<b>".$iso19139Hash[31]['html']."</b>: ".$t_b.$iso19139Hash[31]['value'].$t_c;
			$html .= $t_a."<b>".$iso19139Hash[32]['html']."</b>: ".$t_b.$iso19139Hash[32]['value'].$t_c;
			$html .= $tableEnd;
			$html .= '</fieldset>';
			$html .= '<fieldset><legend>'._mb("Identification").'</legend>';
			$html .= $tableBegin;
			$html .= $t_a."<b>".$iso19139Hash[1]['html']."</b>: ".$t_b.$iso19139Hash[1]['value'].$t_c;//title
			$html .= $t_a."<b>".$iso19139Hash[2]['html']."</b>: ".$t_b.$iso19139Hash[2]['value'].$t_c;//abstract
			$html .= $t_a."<b>".$iso19139Hash[3]['html']."</b>: ".$t_b.$iso19139Hash[3]['value'].$t_c;//type
			if ($iso19139Hash[36]['value'] != "") {
				$html .= $t_a."<b>".$iso19139Hash[36]['html']."</b>: ".$t_b."<img width=120 height=120 src = '".$iso19139Hash[36]['value']."'>".$t_c;//preview
			}
			//resource identifier
			if ($iso19139Hash[37]['value'] != "") {
				//split with #
				$mdIdentifier = explode('#',$iso19139Hash[37]['value']);
				$html .= $t_a."<b>".$iso19139Hash[37]['html']."</b>: ".$t_b.$iso19139Hash[37]['value'].$t_c;//MD Identifier
			} else {
				$html .= $t_a."<b>".$iso19139Hash[5]['html']."</b>: ".$t_b.$iso19139Hash[5]['value'].$t_c;//namespace
				$html .= $t_a."<b>".$iso19139Hash[6]['html']."</b>: ".$t_b.$iso19139Hash[6]['value'].$t_c;//id
			}
			$html .= $t_a."<b>".$iso19139Hash[26]['html']."</b>: ".$t_b.$iso19139Hash[26]['value'].$t_c;//orga name
			$html .= $t_a."<b>".$iso19139Hash[27]['html']."</b>: ".$t_b.$iso19139Hash[27]['value'].$t_c;//email
			$html .= $tableEnd;
			$html .= '</fieldset>';
		
			$bbox = explode(',',$iso19139Hash[12]['value']);

			if (count($bbox) == 4) {
				$wgs84Bbox = $bbox[0].",".$bbox[2].",".$bbox[1].",".$bbox[3];
				$getMapUrl = $this->getExtentGraphic(explode(",", $wgs84Bbox));
				$html .= '<fieldset><legend>'._mb("Extent").'</legend>';
				if (defined('EXTENTSERVICEURL')) {
					$html .= "<img src='".$getMapUrl."'>";
				} else {
					$html .= _mb('Graphic unavailable');
				}
				$html .= '</fieldset>';	
			}
			$html .= '<fieldset><legend>'._mb("Contact").'</legend>';
			$html .= $tableBegin;
			$html .= $t_a."<b>".$iso19139Hash[26]['html']."</b>: ".$t_b.$iso19139Hash[26]['value'].$t_c;
			$html .= $t_a."<b>".$iso19139Hash[27]['html']."</b>: ".$t_b.$iso19139Hash[27]['value'].$t_c;
			$html .= $tableEnd;
			$html .= '</fieldset>';
			$html .= '</p>';
			$html .= '</div>';//element
			//***************************************************************************
			//**************************properties part begin******************************
			//generate div tags for the content - the divs are defined in the array
			if ($layout == 'accordion') {
				$html .= '<h3><a href="#">'._mb("Properties").'</a></h3>';
				$html .= '<div style="height:300px">';
			}
			if ($layout == 'tabs') {
				$html .= '<div id="tabs-2">';
			}
			if ($layout == 'plain') {
				$html .= '<h3>'._mb("Properties").'</h3>';
				$html .= '<div>';
			}
			$html .= '<p>';
			$html .= '<fieldset><legend>'._mb("Common").'</legend>';
			$html .= $tableBegin;
			$html .= $t_a."<b>".$iso19139Hash[8]['html']."</b>: ".$t_b.$iso19139Hash[8]['value'].$t_c;
			$html .= $t_a."<b>".$iso19139Hash[9]['html']."</b>: ".$t_b.$iso19139Hash[9]['value'].$t_c;
			$html .= $t_a."<b>".$iso19139Hash[11]['html']."</b>: ".$t_b.$iso19139Hash[11]['value'].$t_c;
			$html .= $tableEnd;
			$html .= '</fieldset>';
			$html .= '<fieldset><legend>'._mb("Geographic extent").'</legend>';
			$html .= $tableBegin;
			$html .= $t_a."<b>".$iso19139Hash[33]['html']."</b>: ".$t_b.$iso19139Hash[33]['value'].$t_c;
			$html .= $t_a."<b>".$iso19139Hash[12]['html']."</b>: ".$t_b.$iso19139Hash[12]['value'].$t_c;
			$html .= $tableEnd;
			$html .= '</fieldset>';
			$html .= '<fieldset><legend>'._mb("Temporal extent").'</legend>';
			$html .= $tableBegin;
			$html .= $t_a."<b>".$iso19139Hash[13]['html']."</b>: ".$t_b.$iso19139Hash[13]['value'].$t_c;
			$html .= $t_a."<b>".$iso19139Hash[14]['html']."</b>: ".$t_b.$iso19139Hash[14]['value'].$t_c;
			$html .= $t_a."<b>".$iso19139Hash[15]['html']."</b>: ".$t_b.$iso19139Hash[15]['value'].$t_c;
			$html .= $t_a."<b>".$iso19139Hash[16]['html']."</b>: ".$t_b.$iso19139Hash[16]['value'].$t_c;
			$html .= $tableEnd;
			$html .= '</fieldset>';
			if ($iso19139Hash[3]['value'] == 'dataset' || $iso19139Hash[3]['value'] == 'series') {
				$html .= '<fieldset><legend>'._mb("Format").'</legend>';
				$html .= $tableBegin;
				$html .= $t_a."<b>".$iso19139Hash[34]['html']."</b>: ".$t_b.$iso19139Hash[34]['value'].$t_c;
				$html .= $t_a."<b>".$iso19139Hash[35]['html']."</b>: ".$t_b.$iso19139Hash[35]['value'].$t_c;
				$html .= $tableEnd;
				$html .= '</fieldset>';
			}
			if ($iso19139Hash[3]['value'] == 'service') {
				$html .= '<fieldset><legend>'._mb("Service information").'</legend>';
				$html .= $tableBegin;
				$html .= $t_a."<b>".$iso19139Hash[10]['html']."</b>: ".$t_b.$iso19139Hash[10]['value'].$t_c;
				$html .= $t_a."<b>".$iso19139Hash[7]['html']."</b>: ".$t_b.$iso19139Hash[7]['value'].$t_c;
				$html .= $tableEnd;
				$html .= '</fieldset>';
			}
			$html .= '</p>';
			$html .= '</div>';//element
			//***************************************************************************
			//**************************contact part begin******************************
			//generate div tags for the content - the divs are defined in the array
			if ($layout == 'accordion') {
				$html .= '<h3><a href="#">'._mb("Properties").'</a></h3>';
				$html .= '<div style="height:300px">';
			}
			if ($layout == 'tabs') {
				$html .= '<div id="tabs-3">';
			}
			if ($layout == 'plain') {
				$html .= '<h3>'._mb("Properties").'</h3>';
				$html .= '<div>';
			}
			$html .= '<p>';
			$html .= '<fieldset><legend>'._mb("Data/Service provider").'</legend>';
			$html .= $tableBegin;
			$html .= $t_a."<b>".$iso19139Hash[26]['html']."</b>: ".$t_b.$iso19139Hash[26]['value'].$t_c;
			$html .= $t_a."<b>".$iso19139Hash[28]['html']."</b>: ".$t_b.$iso19139Hash[28]['value'].$t_c;
			$html .= $t_a."<b>".$iso19139Hash[27]['html']."</b>: ".$t_b.$iso19139Hash[27]['value'].$t_c;
			$html .= $tableEnd;
			$html .= '</fieldset>';
			$html .= '<fieldset><legend>'._mb("Metadata provider").'</legend>';
			$html .= $tableBegin;
			$html .= $t_a."<b>".$iso19139Hash[29]['html']."</b>: ".$t_b.$iso19139Hash[29]['value'].$t_c;
			$html .= $t_a."<b>".$iso19139Hash[30]['html']."</b>: ".$t_b.$iso19139Hash[30]['value'].$t_c;
			$html .= $tableEnd;
			$html .= '</fieldset>';
			$html .= '</p>';
			$html .= '</div>';//element
			//***************************************************************************
			//**************************terms of use part begin******************************
			//generate div tags for the content - the divs are defined in the array
			if ($layout == 'accordion') {
				$html .= '<h3><a href="#">'._mb("Terms of use").'</a></h3>';
				$html .= '<div style="height:300px">';
			}
			if ($layout == 'tabs') {
				$html .= '<div id="tabs-4">';
			}
			if ($layout == 'plain') {
				$html .= '<h3>'._mb("Terms of use").'</h3>';
				$html .= '<div>';
			}
			$html .= '<p>';
			$html .= '<fieldset><legend>'._mb("Conditions").'</legend>';
			$html .= $tableBegin;
			$html .= $t_a."<b>".$iso19139Hash[23]['html']."</b>: ".$t_b.$iso19139Hash[23]['value'].$t_c;
			$html .= $tableEnd;
			$html .= '</fieldset>';
			$html .= '<fieldset><legend>'._mb("Access constraints").'</legend>';
			$html .= $tableBegin;
			$html .= $t_a."<b>".$iso19139Hash[24]['html']."</b>: ".$t_b.$iso19139Hash[24]['value'].$t_c;
			$html .= $t_a."<b>".$iso19139Hash[25]['html']."</b>: ".$t_b.$iso19139Hash[25]['value'].$t_c;
			$html .= $tableEnd;
			$html .= '</fieldset>';
			$html .= '</p>';
			$html .= '</div>';//element
			//***************************************************************************
			//**************************quality part begin******************************
			//generate div tags for the content - the divs are defined in the array
			if ($layout == 'accordion') {
				$html .= '<h3><a href="#">'._mb("Quality").'</a></h3>';
				$html .= '<div style="height:300px">';
			}
			if ($layout == 'tabs') {
				$html .= '<div id="tabs-5">';
			}
			if ($layout == 'plain') {
				$html .= '<h3>'._mb("Quality").'</h3>';
				$html .= '<div>';
			}
			$html .= '<p>';
			if ($iso19139Hash[3]['value'] == 'dataset' || $iso19139Hash[3]['value'] == 'series') {
				$html .= '<fieldset><legend>'._mb("Lineage").'</legend>';
				$html .= $tableBegin;
				$html .= $t_a."<b>".$iso19139Hash[17]['html']."</b>: ".$t_b.$iso19139Hash[17]['value'].$t_c;
				$html .= $tableEnd;
				$html .= '</fieldset>';
				$html .= '<fieldset><legend>'._mb("Resolution").'</legend>';
				$html .= $tableBegin;
				$html .= $t_a."<b>".$iso19139Hash[18]['html']."</b>: ".$t_b.$iso19139Hash[18]['value'].$t_c;
				$html .= $t_a."<b>".$iso19139Hash[19]['html']."</b>: ".$t_b.$iso19139Hash[19]['value'].$t_c;
				$html .= $tableEnd;
				$html .= '</fieldset>';
			}
			$html .= '<fieldset><legend>'._mb("Validity").'</legend>';
			$html .= $tableBegin;
			$html .= $t_a."<b>".$iso19139Hash[20]['html']."</b>: ".$t_b.$iso19139Hash[20]['value'].$t_c;
			$html .= $t_a."<b>".$iso19139Hash[21]['html']."</b>: ".$t_b.$iso19139Hash[21]['value'].$t_c;
			$html .= $t_a."<b>".$iso19139Hash[22]['html']."</b>: ".$t_b.$iso19139Hash[22]['value'].$t_c;
			$html .= $tableEnd;
			$html .= '</fieldset>';
			$html .= '</p>';
			$html .= '</div>';//element
			//***************************************************************************
			//**************************Interfaces part begin******************************
			//generate div tags for the content - the divs are defined in the array
			if ($layout == 'accordion') {
				$html .= '<h3><a href="#">'._mb("Interfaces").'</a></h3>';
				$html .= '<div style="height:300px">';
			}
			if ($layout == 'tabs') {
				$html .= '<div id="tabs-6">';
			}
			if ($layout == 'plain') {
				$html .= '<h3>'._mb("Interfaces").'</h3>';
				$html .= '<div>';
			}
			$html .= '<p>';
			if ($iso19139Hash[3]['value'] == 'service' && $iso19139Hash[10]['value'] == 'download') {
					//show link to own atom feed download client
					//push ATOM Service feed url to client	
					if (defined("MAPBENDER_PATH") && MAPBENDER_PATH != '' && parse_url($iso19139Hash[7]['value'])) {	
						$html .= $t_a."<b>"._mb("ATOM Feed client")."</b>: <a href='".MAPBENDER_PATH."/plugins/mb_downloadFeedClient.php?url=".urlencode($iso19139Hash[7]['value'])."' target='_blank'>"._mb("Download")."</a>".$t_c;
					}
					
			}
			$html .= '</p>';
			$html .= '<fieldset><legend>'._mb("Metadata").'</legend>';
			$html .= $tableBegin;
			//exchange mdtype html with iso19139
			//$queryNew = str_replace("mdtype=html","mdtype=iso19139",$_SERVER['QUERY_STRING']);
			$html .= $t_a."<b>"._mb("ISO19139")."</b>: <a href='".$this->href."' target='_blank'>"._mb("Metadata")."</a>".$t_c;
			//<a href='".$_SERVER['PHP_SELF']."?".$queryNew."&validate=true' target='_blank'><img style='border: none;' src = '../img/misc/icn_inspire_validate.png' title='"._mb("INSPIRE Validator")."'></a>
			//push xml instead of html? But there is no real url
			$html .= $tableEnd;
			$html .= '</fieldset>';
			$html .= '</p>';
			$html .= '</div>';//element
			//***************************************************************************
			$html .= '</div>'; //accordion
			$html .= '</div>'; //demo
			$html .= '</body>';
			$html .= '</html>';
			return $html;
		}
	}

	public function createFromDBInternalId($metadataId){
		$sql = "SELECT * from mb_metadata WHERE metadata_id = $1";
		$v = array($metadataId);
		$t = array('i');
		$res = db_prep_query($sql,$v,$t);
		if ($res) {
			$row = db_fetch_assoc($res);
			//fill object with information from mb_metadata table
			//initialize empty iso19139 object
			$this->fileIdentifier = $row['uuid'];
			$this->title = $row['title'];
			$this->abstract = $row['abstract'];
			$this->createDate =  $row['createdate'];//"1900-01-01";
			$this->changeDate = $row['changedate'];//"1900-01-01";
			$this->metadata = $row['data'];
			//some possibilities:
			$this->datasetId = $row['datasetid'];
			$this->datasetIdCodeSpace = $row['datasetid_codespace'];

			//fill keywords and categories later cause they are stored in relations!
			/*$this->keywords = array();
			$this->keywordsThesaurusName = array();
			$this->isoCategoryKeys = array();
			//following information is specific to mapbender information model - they are identified by id!
			$this->isoCategories = array();
			$this->inspireCategories = array();
			$this->customCategories = array();
			//*/

			$this->hierachyLevel = $row['type'];
			$this->tmpExtentBegin = $row['tmp_reference_1'];//"1900-01-01";
			$this->tmpExtentEnd = $row['tmp_reference_2'];//"1900-01-01";
			$this->randomId =  $row['randomid'];
			$this->owner = $row['fkey_mb_user_id']; //dummy entry for metadata owner - in case of metadataURL entries the owner of the corresponding service
			$this->href = $row['link'];// "";
			$this->format = $row['md_format'];//"";
			$this->type = $row['linktype'];//"";
			$this->origin = $row['origin'];//"";
			$this->refSystem = $row['ref_system'];//"";
			$this->harvestResult = $row['harvestresult'];//;0;
			$this->harvestException = $row['harvestexception'];//"";
			$this->lineage = $row['lineage'];//"";
			$this->inspireTopConsistence = $row['inspire_top_consistance'];//"f";
			$this->spatialResType = $row['spatial_res_type'];//"";
			$this->spatialResValue = $row['spatial_res_value'];//"";
			$this->export2Csw = $row['export2csw'];//"t";
			$this->updateFrequency = $row['update_frequency'];//"";
			$this->dataFormat = $row['format'];//"";
			$this->inspireCharset = $row['inspire_charset'];//"";
			//
			//$this->linkAlreadyInDB = false;
			//$this->fileIdentifierAlreadyInDB = false;
			//get relations from other tables:
			//get categories and keywords
			//get isoCategories
			$sql = <<<SQL
SELECT md_topic_category_id, md_topic_category_code_en FROM mb_metadata_md_topic_category INNER JOIN md_topic_category ON mb_metadata_md_topic_category.fkey_md_topic_category_id = md_topic_category.md_topic_category_id WHERE mb_metadata_md_topic_category.fkey_metadata_id = $1
SQL;
			$v = array($metadataId);
			$t = array('i');
			$res = db_prep_query($sql,$v,$t);
			while ($row = db_fetch_assoc($res)) {
				$this->isoCategories[]  = (string)$row['md_topic_category_id'];
				$this->isoCategoriesKeys[] = $row['md_topic_category_code_en'];
			}

			//get custom categories
			$sql = <<<SQL
SELECT custom_category_id FROM mb_metadata_custom_category INNER JOIN custom_category ON mb_metadata_custom_category.fkey_custom_category_id = custom_category.custom_category_id WHERE mb_metadata_custom_category.fkey_metadata_id = $1
SQL;
			$v = array($metadataId);
			$t = array('i');
			$res = db_prep_query($sql,$v,$t);
			while ($row = db_fetch_assoc($res)) {
				$this->customCategories[]  = (string)$row['custom_category_id'];
				//generate one keyword entry with special thesaurus 
				$this->keywords[] = $row['fkey_custom_category_id'];
				if (defined("METADATA_DEFAULT_CODESPACE") && METADATA_DEFAULT_CODESPACE != '') {
					$this->keywordsThesaurusName[] = METADATA_DEFAULT_CODESPACE;
				} else {
					$this->keywordsThesaurusName[] = "http://www.mapbender.org";
				}
			}
			//get inspire categories
			$sql = <<<SQL
SELECT inspire_category_id, inspire_category_key FROM mb_metadata_inspire_category INNER JOIN inspire_category ON mb_metadata_inspire_category.fkey_inspire_category_id = inspire_category.inspire_category_id WHERE mb_metadata_inspire_category.fkey_metadata_id = $1
SQL;
			$v = array($metadataId);
			$t = array('i');
			$res = db_prep_query($sql,$v,$t);
			while ($row = db_fetch_assoc($res)) {
				$this->inspireCategories[]  = (string)$row['inspire_category_id'];
				$this->keywords[] = $row['inspire_category_key'];
				$this->keywordsThesaurusName[] = "GEMET - INSPIRE themes, version 1.0";
			}
			//get other keywords from keyword table - only fill in, if not already in keywords!
			$sql = <<<SQL
SELECT keyword FROM mb_metadata_keyword INNER JOIN keyword ON mb_metadata_keyword.fkey_keyword_id = keyword.keyword_id WHERE  mb_metadata_keyword.fkey_metadata_id = $1
SQL;
			$v = array($metadataId);
			$t = array('i');
			$res = db_prep_query($sql,$v,$t);
			while ($row = db_fetch_assoc($res)) {
				if (!in_array($row['keyword'],$this->keywords)) {
					$this->keywords[] = $row['keyword'];
					$this->keywordsThesaurusName[] = "";
				}
			}
		} else {
			$e = new mb_exception("Could not get metadata with id ".$metadataId." from DB!");
		return false;
		}
		return true;
	}

	//the following functions are only for the simple metadata editor
	public function createMetadataAddonFromDB() {
		
	}
	
	public function updateMetadataAddonInDB() {

	}

	//TODO: following 2 functions are not used til now - check plugins mb_metadata_server scripts to exchange handling
	public function deleteMetadataRelation($resourceType, $resourceId, $relationType){
		//delete all relations which are defined from capabilities - this don't delete the metadata entries themself!
		//all other relations stay alive
		$sql = "DELETE FROM ows_relation_metadata WHERE fkey_".$resourceType."_id = $1 AND relation_type = '".$relationType."'";
		$v = array($resourceId);
		$t = array('i');
		$res = db_prep_query($sql,$v,$t);
		if(!$res){
			$e = new mb_exception("class_Iso19139:"."Cannot delete metadata relations for resource ".$resourceType." with id: ".$resourceId);
			return false;
		} else {
			return true;
		}
	}

	public function insertMetadataRelation($resourceType, $resourceId, $relationType){
		//delete all relations which are defined from capabilities - this don't delete the metadata entries themself!
		//all other relations stay alive
		$sql = "DELETE FROM ows_relation_metadata WHERE fkey_".$resourceType."_id = $1 AND relation_type = '".$relationType."'";
		$v = array($resourceId);
		$t = array('i');
		$res = db_prep_query($sql,$v,$t);
		if(!$res){
			$e = new mb_exception("class_Iso19139:"."Cannot delete metadata relations for resource ".$resourceType." with id: ".$resourceId);
			return false;
		} else {
			return true;
		}
	}

	public function checkMetadataRelation($resourceType, $resourceId, $metadataId){
		//check if one relation already exists - if so no new one should be generated!!!
		$sql = "SELECT count(fkey_metadata_id) FROM ows_relation_metadata WHERE fkey_".$resourceType."_id = $1 AND fkey_metadata_id = $2 AND relation_type = $3";
		$v = array($resourceId, $metadataId, $this->origin);
		$t = array('i','i','s');
		$res = db_prep_query($sql,$v,$t);
		while ($row = db_fetch_array($res)){
			$numberOfRelations = $row['count'];	
		}
		if ($numberOfRelations > 0) {
			return true;
		} else {	
			return false;
		}
	}

	public function deleteInternalMetadataLinkage($resourceType, $resourceId, $metadataId){
		$returnObject = array();
		$sql = "DELETE FROM ows_relation_metadata WHERE fkey_metadata_id = $1 and fkey_".$resourceType."_id = $2 and relation_type  = 'internal'";
		$v = array($metadataId, $resourceId);
		$t = array('i','i');
		try {
			$res = db_prep_query($sql,$v,$t);
		}
		catch (Exception $E){
			$returnObject['success'] = false;
			$returnObject['message'] = _mb("Could not delete internal metadata linkage from database!");
			return $returnObject;	
		}
		$returnObject['success'] = true;
		$returnObject['message'] = _mb("Internal metadata linkage deleted!");
		return $returnObject;	
	}

	public function deleteMetadataAddon($resourceType, $resourceId, $metadataId){
		$returnObject = array();
		$sql = "SELECT count(*) as count FROM ows_relation_metadata WHERE fkey_metadata_id = $1";		
		$v = array($metadataId);
		$t = array('i');
		try {
			$res = db_prep_query($sql,$v,$t);
		}
		catch (Exception $e){
			$returnObject['success'] = false;
			$returnObject['message'] = _mb("Could not determine a count of metadata relations!");
			return $returnObject;	
		}
		while ($row = db_fetch_assoc($res)) {
			$countMetadataLinkage = (integer)$row['count']; //integer
		}
		if ($countMetadataLinkage == 1) {
			$e = new mb_exception("Metadata has only one reference and will be deleted from database if it was created by upload or link!");
			//delete the metadata itself cause it has no other reference - really - not right for metador files !!! 
			$sql = <<<SQL

DELETE FROM mb_metadata WHERE metadata_id = $1 and origin NOT IN ('metador')

SQL;
			$v = array($metadataId);
			$t = array('i');
			try {
				$res = db_prep_query($sql,$v,$t);
			}
			catch (Exception $e){
				$returnObject['success'] = false;
				$returnObject['message'] = _mb("Could not delete metadata from database!");
				return $returnObject;	
			}
			//delete link if metadata was not deleted cause it has been created by editor!
			$sql = "DELETE FROM ows_relation_metadata WHERE fkey_metadata_id = $1 and fkey_".$resourceType."_id = $2";
			$v = array($metadataId, $resourceId);
			$t = array('i','i');
			try {
				$res = db_prep_query($sql,$v,$t);
			}
			catch (Exception $E){
				$returnObject['success'] = false;
				$returnObject['message'] = _mb("Could not delete internal metadata linkage from database!");
				return $returnObject;	
			}
			$returnObject['success'] = true;
			$returnObject['message'] = _mb("Metadata and/or linkage was deleted from database!");
			return $returnObject;	
		} else {
			//delete only linkage
			$sql = "DELETE FROM ows_relation_metadata WHERE fkey_metadata_id = $1 and fkey_".$resourceType."_id = $2";
			$v = array($metadataId, $resourceId);
			$t = array('i','i');
			try {
				$res = db_prep_query($sql,$v,$t);
			}
			catch (Exception $E){
				$returnObject['success'] = false;
				$returnObject['message'] = _mb("Could not delete metadata linkage from database!");
				return $returnObject;
			}
			$returnObject['success'] = true;
			$returnObject['message'] = _mb("Metadata linkage deleted!");
			return $returnObject;
		}
	}

	public function isLinkAlreadyInDB(){
		$sql = <<<SQL
SELECT metadata_id FROM mb_metadata WHERE link = $1 AND link <> '' ORDER BY lastchanged DESC
SQL;
		$v = array(
			$this->href
		);
		$t = array('s');
		$res = db_prep_query($sql,$v,$t);
		while ($row = db_fetch_array($res)){
			$metadataId[] = $row['metadata_id'];	
		}
		if (count($metadataId) > 0) {
			return $metadataId;
		} else {	
			return false;
		}
	}
	
	public function isFileIdentifierAlreadyInDB(){
		$sql = <<<SQL
SELECT metadata_id, createdate FROM mb_metadata WHERE uuid = $1 AND uuid <> '' ORDER BY lastchanged DESC
SQL;
		if (!isset($this->fileIdentifier) || $this->fileIdentifier == '') {
			$e = new mb_exception("class_Iso19139:"."Empty or no fileIdentifier found in the metadata! No metadataset will be updated");
			return false;
		}
		$v = array(
			$this->fileIdentifier
		);
		$t = array('s');
		$res = db_prep_query($sql,$v,$t);
		$metadataId = array();
		while ($row = db_fetch_array($res)){
			$metadataId[] = $row['metadata_id'];	
		}
		if (count($metadataId) > 0) {
			return $metadataId;
		} else {	
			return false;
		}
	}

	public function insertKeywordsAndCategoriesIntoDB($metadataId){
		//first delete old classifications - after that create new ones
		$this->deleteKeywordsAndCategoriesFromDB($metadataId);
		//insert keywords and categories into tables!
		//parse keywords and isoCategories
		//INSERT INTO films (code, title, did, date_prod, kind) VALUES
    		//('B6717', 'Tampopo', 110, '1985-02-10', 'Comedy'),
    		//('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');
		//use category name instead of id's!
		//map category name to id before insert them into db!
		//read maptable from db
		//iso - code in xml

		//map keys into relevant ids
		$sqlInsert = "";
		if (count($this->isoCategories) > 0) {
			if (count($this->isoCategories) == 1) {
				$sqlInsert .= "(".(integer)$metadataId.",".(integer)$this->isoCategories.")";
			} else {
				foreach ($this->isoCategories as $isoCategory) {
					$sqlInsert .= "(".(integer)$metadataId.",".(integer)$isoCategory."),";
				}
			}
			$sqlInsert = rtrim($sqlInsert,",");
			$sql = "INSERT INTO mb_metadata_md_topic_category (fkey_metadata_id, fkey_md_topic_category_id) VALUES ".$sqlInsert;
			$res = db_query($sql);
			if (!$res) {
				$e = new mb_exception("class_Iso19139:"._mb("Cannot insert iso categories for this metadata!"));
			}
		}
		$sqlInsert = "";
		if (count($this->inspireCategories) > 0) {
			if (count($this->inspireCategories) == 1) {
				$sqlInsert .= "(".(integer)$metadataId.",".(integer)$this->inspireCategories.")";
			} else {
				foreach ($this->inspireCategories as $inspireCategory) {
					$sqlInsert .= "(".(integer)$metadataId.",".(integer)$inspireCategory."),";
				}
			}
			$sqlInsert = rtrim($sqlInsert,",");
			$sql = "INSERT INTO mb_metadata_inspire_category (fkey_metadata_id, fkey_inspire_category_id) VALUES ".$sqlInsert;
			$res = db_query($sql);
			if (!$res) {
				$e = new mb_exception("class_Iso19139:"._mb("Cannot insert inspire categories for this metadata!"));
			}
		}
		$sqlInsert = "";
		if (count($this->customCategories) > 0) {
			if (count($this->customCategories) == 1) {
				$sqlInsert .= "(".(integer)$metadataId.",".(integer)$this->customCategories.")";
			} else {
				foreach ($this->customCategories as $customCategory) {
					$sqlInsert .= "(".(integer)$metadataId.",".(integer)$customCategory."),";
				}
			}	
			$sqlInsert = rtrim($sqlInsert,",");
			$sql = "INSERT INTO mb_metadata_custom_category (fkey_metadata_id, fkey_custom_category_id) VALUES ".$sqlInsert;
			$res = db_query($sql);
			if (!$res) {
				$e = new mb_exception("class_Iso19139:"._mb("Cannot insert custom categories for this metadata!"));
			}
		}
		$sqlInsert = "";
		//insert keywords into keyword table
		//foreach keyword look for an id or create it newly - made for postgres > 8.2 with returning option for insert statement
		$keyword = "'";
		$keyword .= implode('\',\'',$this->keywords);
		$keyword .= "'";
		$existingKeywords = array();
		$sql = "SELECT keyword, keyword_id from keyword WHERE keyword in ($keyword);";
		$res = db_query($sql);
		if (!$res) {
			$e = new mb_exception("class_Iso19139.php: cannot get keywords from database!");
		} else {
			$countExistingKeywords = 0;
			while ($row = db_fetch_assoc($res)) {
				$existingKeywords[$countExistingKeywords]['keyword'] = $row['keyword'];
				$e = new mb_exception("existing keyword: ".$row['keyword']);
				$existingKeywords[$countExistingKeywords]['id'] = $row['keyword_id'];
				$existingKeywordsArray[$countExistingKeywords] = $row['keyword'];
				$countExistingKeywords++;
			}
		}
		/*foreach ($existingKeywords as $test) {
			$e = new mb_exception("exists: ".$test['keyword']);
		}*/
		//for each existing keyword add a new relation into relation table
		if ($countExistingKeywords > 0) {
			if ($countexistingKeywords == 1) {
				$sqlInsert .= "(".(integer)$metadataId.",".(integer)$existingKeywords[0]['id'].")";
			} else {
				foreach ($existingKeywords as $existingKeyword) {
					$sqlInsert .= "(".(integer)$metadataId.",".(integer)$existingKeyword['id']."),";
				}
			}	
			$sqlInsert = rtrim($sqlInsert,",");
			$sql = "INSERT INTO mb_metadata_keyword (fkey_metadata_id, fkey_keyword_id) VALUES ".$sqlInsert;
			$e = new mb_exception("class_Iso19139.php: sql for keywords: ".$sql);
			$res = db_query($sql);
			if (!$res) {
				$e = new mb_exception("class_Iso19139:"._mb("Cannot insert keyword relations for this metadata!"));
			} else {
				$e = new mb_exception("class_Iso19139:"._mb("Inserted keyword relations for existing keywords!"));
			}
		}
		//insert those keywords, that are not already in the keyword table
		//$this->keywords
		/*$array1 = array("a" => "grün", "rot", "blau", "rot");
		$array2 = array("b" => "grün", "gelb", "rot");
		$result = array_diff($array1, $array2);
		Array
			(
			    [1] => blau
			)
		*/
		$sqlInsert = "";
		//test if $existingKeywordsArray is array!
		if (is_array($existingKeywordsArray)) {
			$otherKeywords = array_values(array_diff($this->keywords,$existingKeywordsArray));
		} else {
			$otherKeywords = $this->keywords;
		} 
		//debug
		foreach ($otherKeywords as $test) {
			$e = new mb_exception("otherKeywords: ".$test);
		}
		$e = new mb_exception("otherKeywords: ".$otherKeywords);
		if (count($otherKeywords) > 0) {
			if (count($otherKeywords) == 1) {
				$e = new mb_exception("Only one new keyword found: ".$otherKeywords[0]);
				//keyword table
				$sqlInsert .= "('".$otherKeywords[0]."')";
			} else {
				foreach ($otherKeywords as $otherKeyword) {
					$sqlInsert .= "('".$otherKeyword."'),";
				}
			}	
			$sqlInsert = rtrim($sqlInsert,",");
			$sql = "INSERT INTO keyword (keyword) VALUES ".$sqlInsert." RETURNING keyword_id" ;
			$e = new mb_exception("class_Iso19139.php: sql for keywords: ".$sql);
			$res = db_query($sql);
			if (!$res) {
				$e = new mb_exception("class_Iso19139:"._mb("Cannot insert new keywords into keyword table!"));
			} else {
				//insert relations for keywords
				$sqlInsert = "";
				$insertedKeywords = array();
				while ($row = db_fetch_assoc($res)) {
					$insertedKeywordIds[] = $row['keyword_id'];
				}
				if (count($insertedKeywordIds) == 1) {
					//keyword relation table
					$sqlInsert .= "(".(integer)$metadataId.",".$insertedKeywordIds[0].")";
				} else {
					foreach ($insertedKeywordIds as $insertedKeywordId) {
						$sqlInsert .= "(".(integer)$metadataId.",".(integer)$insertedKeywordId."),";
					}
				}	
				$sqlInsert = rtrim($sqlInsert,",");
				$sql = "INSERT INTO mb_metadata_keyword (fkey_metadata_id, fkey_keyword_id) VALUES ".$sqlInsert;
				$e = new mb_notice("class_Iso19139.php: sql for keyword relation: ".$sql);
				$res = db_query($sql);
				if (!$res) {
					$e = new mb_exception("class_Iso19139:"._mb("Cannot insert metadata keyword relations into db!"));
				}
			}
		}
	}

	public function deleteKeywordsAndCategoriesFromDB($metadataId) {
		$sql = "DELETE FROM mb_metadata_md_topic_category where fkey_metadata_id = $1 ";
		$v = array($metadataId);
		$t = array('i');
		$res = db_prep_query($sql,$v,$t);
		if (!$res) {
			$e = new mb_exception("class_Iso19139:"._mb("Cannot delete topic category relations for metadata with id ".$metadataId));
		} else {
			$e = new mb_exception("class_Iso19139: topic category relations deleted from database!");
		}
		$sql = "DELETE FROM mb_metadata_inspire_category where fkey_metadata_id = $1 ";
		$v = array($metadataId);
		$t = array('i');
		$res = db_prep_query($sql,$v,$t);
		if (!$res) {
			$e = new mb_exception("class_Iso19139:"._mb("Cannot delete inspire category relations for metadata with id ".$metadataId));
		} else {
			$e = new mb_exception("class_Iso19139: inspire category relations deleted from database!");
		}
		$sql = "DELETE FROM mb_metadata_custom_category where fkey_metadata_id = $1 ";
		$v = array($metadataId);
		$t = array('i');
		$res = db_prep_query($sql,$v,$t);
		if (!$res) {
			$e = new mb_exception("class_Iso19139:"._mb("Cannot delete custom category relations for metadata with id ".$metadataId));
		} else {
			$e = new mb_exception("class_Iso19139: custom category relations deleted from database!");
		}
		//delete keyword relations - problem, that keywords are referenced from more than one table. We can only delete the relations but there may be orphaned keywords, which have to be deleted by cronjob - maybe - TODO
		$sql = "DELETE FROM mb_metadata_keyword where fkey_metadata_id = $1 ";
		$v = array($metadataId);
		$t = array('i');
		$res = db_prep_query($sql,$v,$t);
		if (!$res) {
			$e = new mb_exception("class_Iso19139:"._mb("Cannot delete keyword relations for metadata with id ".$metadataId));
		} else {
			$e = new mb_exception("class_Iso19139: keyword relations deleted from database!");
		}
	}

	public function insertMetadataIntoDB() {
		//insert an instance for iso19139 into mapbenders database
		$sql = <<<SQL
INSERT INTO mb_metadata (lastchanged, link, origin, md_format, data, linktype, uuid, title, createdate, changedate, abstract, searchtext, type, tmp_reference_1, tmp_reference_2, export2csw, datasetid, datasetid_codespace, randomid, fkey_mb_user_id, harvestresult, harvestexception, lineage, inspire_top_consistence, spatial_res_type, spatial_res_value, update_frequency, format, inspire_charset, ref_system)  VALUES(now(), $1, $18, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29)
SQL;
		$v = array(
			$this->href,
			$this->format,
			$this->metadata,
			$this->type,
			$this->fileIdentifier,
			$this->title,
			$this->createDate,
			$this->changeDate,
			$this->abstract,
			$this->keywords[0],
			$this->hierachyLevel,
			$this->tmpExtentBegin,
			$this->tmpExtentEnd,
			$this->export2Csw,
			$this->datasetId,
			$this->datasetIdCodeSpace,
			$this->randomId,
			$this->origin,
			$this->owner,				
			$this->harvestResult,
			$this->harvestException,
			$this->lineage,
			$this->inspireTopConsistence,
			$this->spatialResType,
			$this->spatialResValue,
			$this->updateFrequency,
			$this->dataFormat,
			$this->inspireCharset,
			$this->refSystem	
		);
			$t = array('s','s','s','s','s','s','s','s','s','s','s','s','s','b','s','s','s','s','i','i','s','s','b','s','s','s','s','s','s');
			$res = db_prep_query($sql,$v,$t);
			return $res;
	}


	public function updateMetadataById($metadataId) {
		//check if the timestamp of an existing metadata element is not newer than the timestamp of the current metadata object!!!!
		//TODO
		//problem: <<<SQL have a limited number of chars!
		$sql = "UPDATE mb_metadata SET link = $1, origin = $18, md_format = $2, data = $3, ";
		$sql .= "linktype = $4, uuid = $5, title = $6, createdate = $7, changedate = $8, lastchanged = now(), ";
		$sql .= "abstract = $9, searchtext = $10, type = $11, tmp_reference_1 = $12, tmp_reference_2 = $13, export2csw = $14, datasetid = $15, ";
		$sql .= "datasetid_codespace = $16, randomid = $17, harvestresult = $20, harvestexception = $21, lineage = $22, inspire_top_consistence = $23, ";
		$sql .= "spatial_res_type = $24, spatial_res_value = $25, update_frequency = $26, format = $27, inspire_charset = $28, ref_system = $29 WHERE metadata_id = $19";

		$v = array(
			$this->href,
			$this->format,
			$this->metadata,
			$this->type,
			$this->fileIdentifier, // is the old one! or not?
			$this->title,
			$this->createDate,
			$this->changeDate,
			$this->abstract,
			$this->keywords[0],
			$this->hierachyLevel,
			$this->tmpExtentBegin,
			$this->tmpExtentEnd,
			$this->export2Csw,
			$this->datasetId,
			$this->datasetIdCodeSpace,
			$this->randomId,
			$this->origin,
			//$this->owner, //owner is the old one - maybe here we have something TODO!
			$metadataId, //The first metadataId which was found will be selected!
			$this->harvestResult,
			$this->harvestException,
			$this->lineage,
			$this->inspireTopConsistence,
			$this->spatialResType,
			$this->spatialResValue,
			$this->updateFrequency,
			$this->dataFormat,
			$this->inspireCharset,
			$this->refSystem
		);
		$t = array('s','s','s','s','s','s','s','s','s','s','s','s','s','b','s','s','s','s','i','i','s','s','b','s','s','s','s','s','s');
		$res = db_prep_query($sql,$v,$t);
		return $res;
	}



	public function insertMetadataUrlToDB($resourceType, $resourceId){
		//check if metadata record already exists, if not create a new one else insert relation only!
		$metadataId = $this->isLinkAlreadyInDB();
		if ($metadataId != false) {
			//update the metadataURL entry
			$e = new mb_exception("class_Iso19139:"."existing metadata link(s) found: ".$metadataId[0]." - update will be performed");
			$sql = "UPDATE mb_metadata SET link = $1, origin = $2, md_format = $3, linktype = $4, changedate = now(), export2csw = $5, randomid = $6, harvestresult = $8, harvestexception = $9 WHERE metadata_id = $7";
			$v = array(
				$this->href,
				$this->origin,
				$this->format,
				$this->type,
				'f',
				$this->randomId,
				$metadataId[0],
				$this->harvestResult,
				$this->harvestException
			);
			$t = array('s','s','s','s','b','s','i','i','s');
		} else {
			$sql = "INSERT INTO mb_metadata (link, origin, md_format, linktype, createdate, changedate, export2csw, randomid, fkey_mb_user_id, harvestresult, harvestexception) ";
			$sql .= "VALUES($1, $2, $3, $4, now(), now(), $5, $6, $7, $8, $9)";
			$v = array(
				$this->href,
				$this->origin,
				$this->format,
				$this->type,
				'f',
				$this->randomId,
				$this->owner,
				$this->harvestresult,
				$this->harvestexception
			);
			$t = array('s','s','s','s','b','s','i','i','s');
		}	

		$res = db_prep_query($sql,$v,$t);
		if(!$res){
			db_rollback();
			$e = new mb_exception("class_Iso19139:"._mb("Cannot insert or update metadataUrl in database!"));
			return false;
		} else {
			//insert relation into db
			//get inserted metadata_id
			$sql = <<<SQL
SELECT metadata_id FROM mb_metadata WHERE randomid = $1
SQL;
			//maybe there are more than one results - which should be used??? case of creating new linkage with old metadata TODO TODO
			$v = array($this->randomId);
			$t = array('s');
			try {
				$res = db_prep_query($sql,$v,$t);
			}
			catch (Exception $e){
				$e = new mb_exception("class_Iso19139:"._mb("Cannot get metadata record with following random id from database: ".$this->randomId));
			}
			if (!$res) {
				//do nothing
				$e = new mb_exception("class_Iso19139:"._mb("Cannot find inserted metadata entry to store relation."));
				return false;
			} else {
				//insert relation
				$row = db_fetch_assoc($res);
				$metadataId = $row['metadata_id'];
				//insert relation to layer/featuretype
				$sql = "INSERT INTO ows_relation_metadata (fkey_".$resourceType."_id, fkey_metadata_id, relation_type) values ($1, $2, $3);";	
				$v = array($resourceId, $metadataId, $this->origin);
				$t = array('i','i', 's');
				$res = db_prep_query($sql,$v,$t);
				if(!$res){
					db_rollback();
					$e = new mb_exception("class_Iso19139:"._mb("Cannot insert metadata relation!"));
					return false;
				} else {
					$sql = "UPDATE mb_metadata SET harvestresult = 0, harvestexception = 'Linked metadata could not be interpreted, only linkage is stored to mb_metadata!' where metadata_id = $1";
					$v = array($metadataId);
					$t = array('i');
					$res = db_prep_query($sql,$v,$t);
					if(!$res){
						db_rollback();
						$e = new mb_exception("class_Iso19139:"._mb("Cannot update mb_metadata table!"));
						return false;
					}
				}		
			}
			return true;
		}
		return true;
	}

	private function getExtentGraphic($layer_4326_box) {
		$rlp_4326_box = array(6.05,48.9,8.6,50.96);
		if ($layer_4326_box[0] <= $rlp_4326_box[0] || $layer_4326_box[2] >= $rlp_4326_box[2] || $layer_4326_box[1] <= $rlp_4326_box[1] || $layer_4326_box[3] >= $rlp_4326_box[3]) {
			if ($layer_4326_box[0] < $rlp_4326_box[0]) {
				$rlp_4326_box[0] = $layer_4326_box[0]; 
			}
			if ($layer_4326_box[2] > $rlp_4326_box[2]) {
				$rlp_4326_box[2] = $layer_4326_box[2]; 
			}
			if ($layer_4326_box[1] < $rlp_4326_box[1]) {
				$rlp_4326_box[1] = $layer_4326_box[1]; 
			}
			if ($layer_4326_box[3] > $rlp_4326_box[3]) {
				$rlp_4326_box[3] = $layer_4326_box[3]; 
			}

			$d_x = $rlp_4326_box[2] - $rlp_4326_box[0]; 
			$d_y = $rlp_4326_box[3] - $rlp_4326_box[1];
			
			$new_minx = $rlp_4326_box[0] - 0.05*($d_x);
			$new_maxx = $rlp_4326_box[2] + 0.05*($d_x);
			$new_miny = $rlp_4326_box[1] - 0.05*($d_y);
			$new_maxy = $rlp_4326_box[3] + 0.05*($d_y);

			if ($new_minx < -180) $rlp_4326_box[0] = -180; else $rlp_4326_box[0] = $new_minx;
			if ($new_maxx > 180) $rlp_4326_box[2] = 180; else $rlp_4326_box[2] = $new_maxx;
			if ($new_miny < -90) $rlp_4326_box[1] = -90; else $rlp_4326_box[1] = $new_miny;
			if ($new_maxy > 90) $rlp_4326_box[3] = 90; else $rlp_4326_box[3] = $new_maxy;
		}
		$getMapUrl = EXTENTSERVICEURL."VERSION=1.1.1&REQUEST=GetMap&SERVICE=WMS&LAYERS=".EXTENTSERVICELAYER."&STYLES=&SRS=EPSG:4326&BBOX=".$rlp_4326_box[0].",".$rlp_4326_box[1].",".$rlp_4326_box[2].",".$rlp_4326_box[3]."&WIDTH=120&HEIGHT=120&FORMAT=image/png&BGCOLOR=0xffffff&TRANSPARENT=TRUE&EXCEPTIONS=application/vnd.ogc.se_inimage&minx=".$layer_4326_box[0]."&miny=".$layer_4326_box[1]."&maxx=".$layer_4326_box[2]."&maxy=".$layer_4326_box[3];
		return $getMapUrl;
	}


	public function insertToDB($resourceType, $resourceId){
		$result = array(); //value/message
		switch ($this->origin) {
			case "capabilities":
				//check if href is given and resource can be parsed
				//following information must be given:
				//randomId, href, format, type, origin, owner
				//TODO: that empty identifier not identified - see comparing linkage
				if ((($this->type == 'ISO19115:2003' || $this->type == 'ISO 19115:2003') && $this->format =='text/xml') || ($this->type == 'TC211' && $this->format =='text/xml') || (($this->type == 'ISO19115:2003' || $this->type == 'ISO 19115:2003') && ($this->format =='application/vnd.iso.19139+xml' || $this->format =='application/xml'))) {
					$e = new mb_notice("class_Iso19139:"."try to parse: ".$this->href);
					$metadata = $this->createFromUrl($this->href); //will alter object itself
					$e = new mb_notice("class_Iso19139:"."Metadata found: ".$this->metadata);
					if ($metadata == false) {
						//try to insert only MetadataURL elements
						if (!$this->insertMetadataUrlToDB($resourceType, $resourceId)) {
							$e = new mb_exception("class_Iso19139:"."Problem while storing MetadataURL entry from wms capabilities to mb_metadata table!");
							$result['value'] = false;
							$result['message'] = "Problem while storing MetadataURL entry from wms capabilities to mb_metadata table!";
							return $result;
						} else {
							
							$e = new mb_exception("class_Iso19139:"."Storing only MetadataURL ".$metadata->href." from capabilities to mb database cause the target could not be accessed or parsed!");
							$result['value'] = true;
							$result['message'] = "Storing only MetadataURL ".$metadata->href." from capabilities to mb database cause the target could not be accessed or parsed!";
							return $result;
						}
					} 
				} else {
					$e = new mb_exception("class_Iso19139:"."MetadataURL format or type of following url is not supported: Format: ".$this->format." | type: ".$this->type);
				}
				break;
			case "external":
				//don't check format and type -cause they are not given. Otherwise the same as in case of capabilities
				$metadata = $this->createFromUrl($this->href); //will alter object itself
				if ($metadata == false) {
					//try to insert only MetadataURL elements
					if (!$this->insertMetadataUrlToDB($resourceType, $resourceId)) {
						$e = new mb_exception("class_Iso19139:"."Problem while storing MetadataURL entry from wms capabilities to mb_metadata table!");
						$result['value'] = false;
						$result['message'] = "Problem while storing MetadataURL entry from wms capabilities to mb_metadata table!";
						return $result;
					} else {
						$e = new mb_exception("class_Iso19139:"."Storing only MetadataURL ".$metadata->href." from capabilities to mb database cause the target could not be accessed or parsed!");
						$result['value'] = true;
						$result['message'] = "Storing only MetadataURL ".$metadata->href." from capabilities to mb database cause the target could not be accessed or parsed!";
						return $result;
					}
				} 
				break;
			case "metador":
				//nothing to do at all?
				break;
			case "upload":
				//nothing to do at all?
				$e = new mb_exception("class_Iso19139:"."upload found");
				//$e = new mb_exception($this->metadata);
				$metadata = $this->createMapbenderMetadataFromXML($this->metadata);
				
				if ($metadata == false) {
					//xml could not be parsed
					$result['value'] = false;
					$result['message'] = "Metadata object could not be created!";
					return $result;
				}
				//else save it into database
				break;
			/*case "internal":
				//only set relation to existing record - return true;
				//is actually handled thru plugins/mn_metadata_server* 
				break;*/
			default:
       				$e = new mb_exception("class_Iso19139:"."Metadata origin is not known - please set it before storing values to DB!");
				$result['value'] = false;
				$result['message'] = "Metadata origin is not known - please set it before storing values to DB!";
				return $result;
		}

		//check if metadata record already exists, if not create a new one, else insert relation only and update the metadata itself!
		$metadataId = $this->isFileIdentifierAlreadyInDB();

		if ($metadataId != false) {
			//update the metadata - new random id set therefor there is no problem when setting the relation afterwards
			$e = new mb_exception("existing metadata fileIdentifier found at metadata with id: ".$metadataId[0]." - update will be performed");
			//check if the timestamp of an existing metadata element is not newer than the timestamp of the current metadata object!!!!
			$res = $this->updateMetadataById($metadataId[0]);
		} else {
			//check if href already exists
			$metadataId = $this->isLinkAlreadyInDB();
			//if so, the metadataset will be the same - (same url same metadataset) - update this as before
			if ($metadataId != false) {
				//the link to an existing metadataset already exists - don't store it again or insert anything
				$e = new mb_exception("existing metadata linkage found at metadata with id: ".$metadataId[0]." - update will be performed");
				//check if the timestamp of an existing metadata element is not newer than the timestamp of the current metadata object!!!!
				$res = $this->updateMetadataById($metadataId[0]);
			} else {
				//insert new record
				$e = new mb_exception("class_Iso19139:"."No existing metadata fileIdentifier found in mapbender metadata table. New record will be inserted with uuid: ".$this->fileIdentifier);
				$res = $this->insertMetadataIntoDB();
			}
		}
		if(!$res){
			db_rollback();
			$e = new mb_exception("class_Iso19139:"._mb("Cannot insert or update metadata record into mapbenders mb_metadata table!"));
			$result['value'] = false;
			$result['message'] = "Cannot insert or update metadata record into mapbenders mb_metadata table!";
			return $result;
		} else {
			//insert relation into db
			//get inserted metadata_id by use the 
			$sql = <<<SQL
SELECT metadata_id FROM mb_metadata WHERE randomid = $1
SQL;
			$v = array($this->randomId);
			$t = array('s');
			try {
				$res = db_prep_query($sql,$v,$t);
			}
			catch (Exception $e){
				$e = new mb_exception("class_Iso19139:"._mb("Cannot get metadata record with following uuid from database: ".$this->randomId));
			}
			if (!$res) {
				//do nothing
				$e = new mb_exception("class_Iso19139:"._mb("Cannot get metadata record with following uuid from database: ".$this->randomId));
				$result['value'] = false;
				$result['message'] = "Cannot get metadata record with following uuid from database: ".$uuid;
				return $result;
			} else {
				//insert relation
				$row = db_fetch_assoc($res);
				$metadataId = $row['metadata_id'];
				//check if current relation already exists in case of upload
				if ($this->checkMetadataRelation($resourceType, $resourceId, $metadataId)) {
					$e = new mb_exception("class_Iso19139:"._mb("Relation already exists - it will not be generated twice!"));
					$result['value'] = true;
					$result['message'] = "Relation already exists - it will not be generated twice!";
					return $result;
				}
				//insert relation to layer/featuretype
				$sql = "INSERT INTO ows_relation_metadata (fkey_".$resourceType."_id, fkey_metadata_id, relation_type) values ($1, $2, $3);";
				$v = array($resourceId, $metadataId, $this->origin);
				$t = array('i','i','s');
				$res = db_prep_query($sql,$v,$t);
				if(!$res){
					db_rollback();
					$e = new mb_exception("class_Iso19139:"._mb("Cannot insert metadata relation!"));
					$result['value'] = false;
					$result['message'] = "Cannot insert metadata relation!";
					return $result;
				} else {
					$sql = "UPDATE mb_metadata SET harvestresult = 1 where metadata_id = $1";
					$v = array($metadataId);
					$t = array('i');
					$res = db_prep_query($sql,$v,$t);
					if(!$res){
						db_rollback();
						$e = new mb_exception("class_Iso19139:"._mb("Cannot update mb_metadata table to fill in harvest result!"));
						$result['value'] = false;
						$result['message'] = "Cannot update mb_metadata table to fill in harvest result!";
						return $result;
					} else {
						$this->insertKeywordsAndCategoriesIntoDB($metadataId);	
					}
				} 	
			}
			$result['value'] = true;
			$result['message'] = "Insert metadata successfully into database!";
			return $result;
		}
		
	}
	
}
?>
